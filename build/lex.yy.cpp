// lex.yy.cpp generated by reflex 1.0.9 from /mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_YYLTYPE             yy::location
#define REFLEX_OPTION_YYSTYPE             yy::parser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  yy
#define REFLEX_OPTION_bison_cc_parser     parser
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_header_file         lex.yy.h
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           yy
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             lex.yy.cpp

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"

// Quack scanner
// Acknowledgements: Michal Young for skeleton file

#include "quack.tab.hxx"  // Generated by bison.
#include "Messages.h"



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace yy {

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int comment = 1;
  static const int string = 2;
  static const int multistring = 3;
  virtual int yylex(yy::parser::semantic_type *yylval, yy::location *yylloc)
  {
    yylloc->step();
    int ret = yylex(*yylval);
    yylloc->end.line = matcher().lineno();
    yylloc->end.column = matcher().columno();
    return ret;
  }
  virtual int yylex(yy::parser::semantic_type& yylval);
};

} // namespace yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 10 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"

// Externally visible file name -- for error messages.
// FIXME: Need to extract this from structures that reflex passes
// or else find another way to dig it out.
std::string yyfilename = "Quack";

// Some strings can't be matched in one gulp.  We need
// a buffer in which to assemble them from parts.
std::string string_buf = "";

void yyerror (const std::string &msg, yy::position* where) {
     std::cout << where << ": " << msg;
}

std::string unclosedStringMsg(int lineno, int columno) {
    return "possible unclosed string at line " + std::to_string(lineno) + ", column " + std::to_string(columno);
}

std::string BAD_ESC_MSG =
    "illegal escape code; only \\\\, \\0, \\t, \\n, \\r, and \\n are permitted";

std::string badEscMsg(int lineno, int columno) {
    return BAD_ESC_MSG + "... found at line " + std::to_string(lineno) + ", column " + std::to_string(columno);
}

std::string UNCLOSED_COMMENT_MSG =
    "possible unclosed multiline comment, reason: EOF encountered; exiting with error code 4";

std::string UNCLOSED_STRING_MSG =
    "possible unclosed multiline string, reason: EOF encountered; exiting with error code 4";

std::string unexpectedCharMsg(int lineno, int columno, const char *text) {
    return "unexpected character '" + std::string(text) + "'" + " at line " + std::to_string(lineno) +
           ", column " + std::to_string(columno);
}


#line 51 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
/* ============== */
/* Scanner States */
/* ============== */


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

int yy::Lexer::yylex(yy::parser::semantic_type& yylval)
{
  static const reflex::Pattern PATTERN_INITIAL("(?m)(==)|([<]=)|([>]=)|([(-/:->\\x7b\\x7d])|(class)|(def)|(extends)|(if)|(elif)|(else)|(while)|(return)|(typecase)|(and)|(or)|(not)|([0-9]+)|([A-Z_a-z][0-9A-Z_a-z]*)|(\")|(\"\"\")|([\\x09\\x0a\\x0d\\x20]*)|((?:\\Q//\\E).*)|([/][\\x2a])|(.)");
  static const reflex::Pattern PATTERN_comment("(?m)([^\\x2a]*)|([\\x2a][^/])|([\\x2a][/])");
  static const reflex::Pattern PATTERN_string("(?m)(\")|(\\n)|(\\\\[^\"0\\x5cbfnrt])|(\\\\0)|(\\\\b)|(\\\\t)|(\\\\n)|(\\\\r)|(\\\\f)|(\\\\\")|(\\\\\\\\)|(.)");
  static const reflex::Pattern PATTERN_multistring("(?m)(\"\"\")|(\\n)|(\\r)|(\\t)|(.)");
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  switch (start())
  {
    case INITIAL:
#line 62 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
/* ======================== */
/* Non-Value Bearing Tokens */
#line 65 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
/* ======================== */

// Multi-character punctuation with names
    break;
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 152 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return EOF; }

            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 66: ==
#line 66 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::EQUALS; }
            break;
          case 2: // rule at line 67: [<]=
#line 67 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::ATMOST; }
            break;
          case 3: // rule at line 68: [>]=
#line 68 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::ATLEAST; }


            break;
          case 4: // rule at line 75: [(-/:->\x7b\x7d]
#line 75 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return text()[0]; }

            break;
          case 5: // rule at line 82: class
#line 82 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::CLASS; }
            break;
          case 6: // rule at line 83: def
#line 83 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::DEF; }
            break;
          case 7: // rule at line 84: extends
#line 84 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::EXTENDS; }
            break;
          case 8: // rule at line 85: if
#line 85 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::IF; }
            break;
          case 9: // rule at line 86: elif
#line 86 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::ELIF; }
            break;
          case 10: // rule at line 87: else
#line 87 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::ELSE; }
            break;
          case 11: // rule at line 88: while
#line 88 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::WHILE; }
            break;
          case 12: // rule at line 89: return
#line 89 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::RETURN; }
            break;
          case 13: // rule at line 90: typecase
#line 90 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::TYPECASE; }
            break;
          case 14: // rule at line 91: and
#line 91 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::AND; }
            break;
          case 15: // rule at line 92: or
#line 92 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::OR; }
            break;
          case 16: // rule at line 93: not
#line 93 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return parser::token::NOT; }


            break;
          case 17: // rule at line 108: [0-9]+
#line 108 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ yylval.num = atoi(text()); return parser::token::INT_LIT; }

            break;
          case 18: // rule at line 111: [A-Z_a-z][0-9A-Z_a-z]*
#line 111 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ yylval.str = strdup(text()); return parser::token::IDENT; }

            break;
          case 19: // rule at line 114: "
#line 114 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.clear(); start(string); }
            break;
          case 20: // rule at line 129: """
#line 129 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.clear(); start(multistring); }
            break;
          case 21: // rule at line 138: [\x09\x0a\x0d\x20]*
#line 138 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ ; }

            break;
          case 22: // rule at line 141: (?:\Q//\E).*
#line 141 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ ; }

            break;
          case 23: // rule at line 144: [/][\x2a]
#line 144 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ start(comment); }
            break;
          case 24: // rule at line 150: .
#line 150 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ report::error(unexpectedCharMsg(lineno(), columno(), text()), LEXER); }

            break;
        }
        break;
      case comment:
        matcher().pattern(PATTERN_comment);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 147 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ report::error(UNCLOSED_COMMENT_MSG, LEXER); report::bail(LEXER); }
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 145: [^\x2a]*
#line 145 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ ; }
            break;
          case 2: // rule at line 146: [\x2a][^/]
#line 146 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ ; }
            break;
          case 3: // rule at line 148: [\x2a][/]
#line 148 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ start(INITIAL); }

            break;
        }
        break;
      case string:
        matcher().pattern(PATTERN_string);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 152 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ return EOF; }

            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 115: "
#line 115 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ start(INITIAL); yylval.str = strdup(string_buf.c_str()); return parser::token::STRING_LIT; }
            break;
          case 2: // rule at line 116: \n
#line 116 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ start(INITIAL); report::error(unclosedStringMsg(lineno(), columno()), LEXER); }
            break;
          case 3: // rule at line 117: \\[^"0\x5cbfnrt]
#line 117 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ report::error(badEscMsg(lineno(), columno()), LEXER); }
            break;
          case 4: // rule at line 118: \\0
#line 118 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\0"); }
            break;
          case 5: // rule at line 119: \\b
#line 119 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\b"); }
            break;
          case 6: // rule at line 120: \\t
#line 120 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\t"); }
            break;
          case 7: // rule at line 121: \\n
#line 121 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\n"); }
            break;
          case 8: // rule at line 122: \\r
#line 122 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\r"); }
            break;
          case 9: // rule at line 123: \\f
#line 123 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\f"); }
            break;
          case 10: // rule at line 124: \\"
#line 124 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\""); }
            break;
          case 11: // rule at line 125: \\\\
#line 125 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\\"); }
            break;
          case 12: // rule at line 126: .
#line 126 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append(text()); }

            break;
        }
        break;
      case multistring:
        matcher().pattern(PATTERN_multistring);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
#line 131 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ report::error(UNCLOSED_STRING_MSG, LEXER); report::bail(LEXER); }
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 130: """
#line 130 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ start(INITIAL); yylval.str = strdup(string_buf.c_str()); return parser::token::STRING_LIT; }
            break;
          case 2: // rule at line 132: \n
#line 132 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\n"); }
            break;
          case 3: // rule at line 133: \r
#line 133 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\r"); }
            break;
          case 4: // rule at line 134: \t
#line 134 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append("\t"); }
            break;
          case 5: // rule at line 135: .
#line 135 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"
{ string_buf.append(text()); }

            break;
        }
        break;
      default:
        return 0;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 155 "/mnt/c/Users/andre/Desktop/College/461 - Compiler Construction/Quack-Compiler/src/quack.lxx"

// No main program here

