/* Quack parser
 * Author: Andrew Letz
 * Acknowledgements: Michal Young for some code from reflex-bison-ast repo
 */ 
%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }
}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */

}

%union {
    int   num;
    char* str;
}

/* -~-~-~ TOKENS -~-~-~ */
%token <str> STRING_LIT
%token <int> INT_LIT

%token CLASS DEF EXTENDS
%token IF ELIF ELSE
%token WHILE RETURN TYPECASE
%token ATLEAST ATMOST EQUALS
%token AND OR NOT
%token IDENT
%token NEG

/* -~-~-~ PRECEDENCE -~-~-~ */
%left AND OR NOT
%left EQUALS ATMOST ATLEAST '<' '>'
%left '-' '+'
%left '*' '/'
%left UMINUS

/* -~-~-~-~-~-~-~-~-~-~-~- GRAMMAR -~-~-~-~-~-~-~-~-~-~-~- */

%%

program : classes stmts
        ;

class : class_sig class_body
        ;

classes : classes class
        | /* empty */
        ;

class_sig : CLASS IDENT '(' formal_args ')'
        | CLASS IDENT '(' formal_args ')' EXTENDS IDENT
        ;

formal_args : IDENT ':' IDENT formal_arg
        | /* empty */
        ;

formal_arg : formal_arg ',' IDENT ':' IDENT 
        | /* empty */
        ;

stmt : IF r_expr stmt_block elif_nts
        | IF r_expr stmt_block elif_nts ELSE stmt_block
        | WHILE r_expr stmt_block
        | l_expr '=' r_expr ';'
        | l_expr ':' IDENT '=' r_expr ';'
        | r_expr ';'
        | RETURN r_expr ';'
        | RETURN ';'
        | typecase
        ;

typecase : TYPECASE r_expr '{' type_alts '}'
        ;

type_alts : type_alts type_alt
        | /* empty */
        ;

type_alt : IDENT ':' IDENT stmt_block
        ;

elif_nt : ELIF r_expr stmt_block
        ;

elif_nts : elif_nts elif_nt
        | /* empty */
        ;

stmts : stmts stmt
        | /* empty */
        ;

stmt_block : '{' stmts '}'
        ;

r_expr : STRING_LIT
        | INT_LIT
        | l_expr
        | '-' r_expr %prec UMINUS
        | r_expr '*' r_expr
        | r_expr '/' r_expr
        | r_expr '+' r_expr
        | r_expr '-' r_expr
        | r_expr EQUALS r_expr
        | r_expr ATMOST r_expr
        | r_expr '<' r_expr
        | r_expr ATLEAST r_expr
        | r_expr '>' r_expr
        | r_expr AND r_expr
        | NOT r_expr
        | r_expr OR r_expr
        | '(' r_expr ')'
        | r_expr '.' IDENT '(' actual_args ')'
        | IDENT '(' actual_args ')'
        ;

actual_args : r_expr actual_arg
        | /* empty */
        ;

actual_arg : actual_arg ',' r_expr
        | /* empty */
        ;

l_expr : IDENT
        | r_expr '.' IDENT
        ;

method : DEF IDENT '(' formal_args ')' stmt_block
        | DEF IDENT '(' formal_args ')' ':' IDENT stmt_block
        ;

methods : methods method
        | /* empty */
        ;

class_body : '{' stmts methods '}'
        ;

%%

/* -~-~-~-~-~-~-~-~-~-~-~- -~-~-~- -~-~-~-~-~-~-~-~-~-~-~- */

#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
    report::error_at(loc, msg);
}
