/* Quack parser
 * Author: Andrew Letz
 * Acknowledgements: Michal Young for some code from reflex-bison-ast repo
 */ 
%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree


}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);

}

%union {
    int   num;
    char* str;
    AST::ASTNode* node;
    // block needs a more explicit type to use the 'append' method
    AST::Block* block;
}

/* -~-~-~ TOKENS -~-~-~ */
%token <str> STRING_LIT
%token <int> INT_LIT

%token CLASS DEF EXTENDS
%token IF ELIF ELSE
%token WHILE RETURN TYPECASE
%token ATLEAST ATMOST EQUALS
%token AND OR NOT
%token IDENT
%token NEG

/* -~-~-~ AST NODES -~-~-~ */
%type <node> program

/* -~-~-~-~-~-~-~-~-~-~-~- GRAMMAR -~-~-~-~-~-~-~-~-~-~-~- */

%%

program: IF { std::cout << "Found if" << std::endl; } ;

%%

/* -~-~-~-~-~-~-~-~-~-~-~- -~-~-~- -~-~-~-~-~-~-~-~-~-~-~- */

#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  report::error_at(loc, msg);
}

void dump(AST::ASTNode* n) {
    // std::cout << "*** Building: " << n->str() << std::endl;
}