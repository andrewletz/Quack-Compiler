/* Quack parser driver
 * Author: Andrew Letz
 * Acknowledgements: Michal Young for some code from reflex-bison-ast repo
 */ 

#include "lex.yy.h"
#include "ASTNode.h"
#include "EvalContext.h"
#include "Messages.h"

class Driver {
public:

    /* Constructor
        reflex::Input : used to create the lexer, which feeds tokens to the parser 
        parser        : defined in  quack.tab.hxx & cxx. arguments defined in quack.yxx.
            lexer     : used to override the default lexer in bison (yylex) when parsing
            &root     : given to the parser and initialized to the root ASTNode when parsing.
                        used to pass the ASTNode back here.
    */
    explicit Driver(reflex::Input in) : lexer(in), parser(new yy::parser(lexer, &root))
    { root = nullptr; }

    /* Deconstructor */
    virtual ~Driver() { delete parser; }

    /* parse: attempts to parse the given program (lexed by input lexer).
       root is an ASTNode ** in quack.yxx, used to pass the root back here */
    AST::ASTNode* parse() {
        // parser->set_debug_level(1); // 0 = no debugging, 1 = full tracing

        /* parse() is defined by Bison. it will return 0 if the parse succeeds, 1 if it fails */
        int result = parser->parse();
        if (result == 0 && report::ok()) {  // 0 == success, 1 == failure
            if (root == nullptr) {
                std::cout << "AST Root is null.\n";
            }
            return root; /* program was legal*/
        } else {
            std::cout << "Parse failed, no tree\n";
            return nullptr; /* if the parse fails, we don't want an AST */
        }
    }

private:
    /* yy::Lexer is generated by RE\flex, located inside lex.yy.h & cpp.
    It takes a reflex::Input, and an ostream, which defaults to std::cout. */
    yy::Lexer lexer;
    yy::parser *parser; /* our parser class generated by Bison, holds our parse() function */
    AST::ASTNode *root; /* so we can get our AST back here */

};

int main()
{
    Driver driver(std::cin);
    AST::ASTNode* root = driver.parse();

    if (root != nullptr) {
        AST::AST_print_context context;

        std::cout << std::endl;
        root->json(std::cout, context);
        std::cout << std::endl;
    } else {
        std::cout << "Extracted root was nullptr" << std::endl; /* either the parse failed, or no AST was built */
    }
}
