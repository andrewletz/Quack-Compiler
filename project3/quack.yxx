%skeleton "lalr1.cc"
%require  "3.0"

// This is how to get the header files into the parser as well
// as include whatever you wish in the files it generates
%code requires {
  namespace yy {
    class Lexer;  // RE/Flex generates this class with namespace=yy lexer=Lexer
  }
  #include "ASTNode.h"  // Including the AST Classes
}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code {
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  // Within Bison's parse() we should invoke lexer.yylex(), not the global yylex()
    void dump(AST::ASTNode* n);
}

%union {
    int   num;
    char* str;
    AST::ASTNode* node;
}

// -~-~-~- TOKENS -~-~-~-
%token <str> STRING_LIT
%token <num> INT_LIT

%token CLASS DEF EXTENDS
%token IF ELIF ELSE
%token WHILE RETURN TYPECASE
%token ATLEAST ATMOST EQUALS
%token AND OR NOT
%token IDENT
%token NEG

// -~-~-~- AST NODES -~-~-~-
%type <str> IDENT
%type <node> program
%type <node> classes
%type <node> class
%type <node> class_sig
%type <node> class_body
%type <node> formal_args
%type <node> formal_args_extra
%type <node> stmt_block
%type <node> stmts
%type <node> stmt
%type <node> elif_nts
%type <node> elif_nt
%type <node> typecase
%type <node> type_alts
%type <node> type_alt
%type <node> r_expr
%type <node> actual_args
%type <node> actual_args_extra
%type <node> l_expr
%type <node> method
%type <node> methods
%type <node> ident

// -~-~-~- PRECEDENCE -~-~-~-
%left AND OR NOT
%left EQUALS ATMOST ATLEAST '<' '>'
%left '-' '+'
%left '*' '/'
%left '.'
%left UMINUS

// -~-~-~- GRAMMAR -~-~-~-

%%

program
        : classes stmts { *root = new AST::ASTNode(PROGRAM); $$ = *root; $$->insert($1); $$->insert($2); }
        ;

classes
        : classes class { $1->insert($2); $$ = $1; }
        | /* empty */   { $$ = new AST::ASTNode(CLASSES); }
        ;

class
        : class_sig class_body { $$ = $1; $1->insert($2); }
        ;

class_sig
        : CLASS ident '(' formal_args ')' { $$ = new AST::ASTNode(CLASS); $$->insert($2);$$->insert($4); }
        | CLASS ident '(' formal_args ')' EXTENDS ident { $$ = new AST::ASTNode(CLASS); $$->insert($2); $$->insert($4); $$->insert($7); }
        ;

class_body 
        : '{' stmts methods '}' { $$ = new AST::ASTNode(BLOCK); $$->insert($2); $$->insert($3); }
        ;

formal_args
        : ident ':' ident formal_args_extra { $$ = new AST::ASTNode(FORMAL_ARGS); $$->insert($1); $$->insert($3); $$->insert($4); }
        | /* empty */ { $$ = NULL; } // when this is passed back to class_sig we don't want to insert a null node
        ;

formal_args_extra
        : formal_args_extra ',' ident ':' ident { $$ = new AST::ASTNode(FORMAL_ARGS_EXTRA); $$->insert($3); $$->insert($5); }
        | /* empty */ { $$ = NULL; }
        ;

stmt_block
        : '{' stmts '}' { $$ = new AST::ASTNode(BLOCK); $$->insert($2); }
        ;

stmts
        : stmts stmt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(BLOCK); }
        ;

stmt
        : IF r_expr stmt_block elif_nts { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); $$->insert($4); }
        | IF r_expr stmt_block elif_nts ELSE stmt_block { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); $$->insert($4); $$->insert($6); }
        | WHILE r_expr stmt_block { $$ = new AST::ASTNode(WHILE); $$->insert($3); }
        | l_expr '=' r_expr ';' { $$ = new AST::ASTNode(ASSIGN); $$->insert($1); $$->insert($3); }
        | l_expr ':' ident '=' r_expr ';' { $$ = new AST::ASTNode(ASSIGN); $$->insert($1); $$->insert($3); $$->insert($5); }
        | r_expr ';' { $$ = $1; }
        | RETURN r_expr ';' { $$ = new AST::ASTNode(RETURN); $$->insert($2); }
        | RETURN ';' { $$ = new AST::ASTNode(RETURN); }
        | typecase { $$ = $1; }
        ;

elif_nts 
        : elif_nts elif_nt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(IF); }
        ;

elif_nt 
        : ELIF r_expr stmt_block { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); }
        ;

typecase
        : TYPECASE r_expr '{' type_alts '}' { $$ = new AST::ASTNode(TYPECASE); $$->insert($2); $$->insert($4); }
        ;

type_alts
        : type_alts type_alt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(TYPE_ALTERNATIVES); }
        ;

type_alt 
        : ident ':' ident stmt_block { $$ = new AST::ASTNode(TYPE_ALTERNATIVE); $$->insert($1); $$->insert($3); $$->insert($4); }
        ;

r_expr
        : STRING_LIT { $$ = new AST::ASTNode(STRCONST, std::string($1)); }
        | INT_LIT { $$ = new AST::ASTNode(INTCONST, $1); }
        | l_expr { $$ = $1; }
        | '-' r_expr %prec UMINUS { $$ = new AST::ASTNode(BINOP, "UMINUS"); $$->insert($2); }
        | r_expr '*' r_expr { $$ = new AST::ASTNode(BINOP, "MULT"); $$->insert($1); $$->insert($3); }
        | r_expr '/' r_expr { $$ = new AST::ASTNode(BINOP, "DIV"); $$->insert($1); $$->insert($3); }
        | r_expr '+' r_expr { $$ = new AST::ASTNode(BINOP, "PLUS"); $$->insert($1); $$->insert($3); }
        | r_expr '-' r_expr { $$ = new AST::ASTNode(BINOP, "MINUS"); $$->insert($1); $$->insert($3); }
        | r_expr EQUALS r_expr { $$ = new AST::ASTNode(BINOP, "EQ"); $$->insert($1); $$->insert($3); }
        | r_expr ATMOST r_expr { $$ = new AST::ASTNode(BINOP, "ATMOST"); $$->insert($1); $$->insert($3); }
        | r_expr '<' r_expr { $$ = new AST::ASTNode(BINOP, "LESSER"); $$->insert($1); $$->insert($3);}
        | r_expr ATLEAST r_expr { $$ = new AST::ASTNode(BINOP, "ATLEAST"); $$->insert($1); $$->insert($3); }
        | r_expr '>' r_expr { $$ = new AST::ASTNode(BINOP, "GREATER"); $$->insert($1); $$->insert($3); }
        | r_expr AND r_expr { $$ = new AST::ASTNode(AND); $$->insert($1); $$->insert($3); }
        | NOT r_expr { $$ = new AST::ASTNode(NOT); $$->insert($2); }
        | r_expr OR r_expr { $$ = new AST::ASTNode(OR); $$->insert($1); $$->insert($3); }
        | '(' r_expr ')' { $$ = $2; }
        | r_expr '.' ident '(' actual_args ')' { $$ = new AST::ASTNode(DOT); $$->insert($1); $$->insert($3); $$->insert($5);}
        | ident '(' actual_args ')' { $$ = new AST::ASTNode(CALL); $$->insert($1); $$->insert($3); }
        ;

actual_args
        : r_expr actual_args_extra { $$ = new AST::ASTNode(ACTUAL_ARGS); $$->insert($1); $$->insert($2); }
        | /* empty */ { $$ = NULL; }
        ;

actual_args_extra
        : actual_args_extra ',' r_expr { $$ = new AST::ASTNode(ACTUAL_ARGS_EXTRA); $$->insert($1); $$->insert($3); }
        | /* empty */ { $$ = NULL; }
        ;

l_expr
        : ident { $$ = new AST::ASTNode(L_EXPR); $$->insert($1); }
        | r_expr '.' ident { $$ = new AST::ASTNode(L_EXPR); $$->insert($1); $$->insert($3); }
        ;

method
        : DEF ident '(' formal_args ')' stmt_block { $$ = new AST::ASTNode(METHOD); $$->insert($2); $$->insert($4); $$->insert($6); }
        | DEF ident '(' formal_args ')' ':' ident stmt_block { $$ = new AST::ASTNode(METHOD); $$->insert($2); $$->insert($4); $$->insert($7); $$->insert($8); }
        ;

methods
        : methods method { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(METHODS); }
        ;

ident
        : IDENT { $$ = new AST::ASTNode(IDENT, $1); }
        ;

%%

// -~-~-~- -~-~-~- -~-~-~-~

#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
    report::error_at(loc, msg);
}