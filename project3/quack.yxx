/* Quack parser
 * Author: Andrew Letz
 * Acknowledgements: Michal Young for some code from reflex-bison-ast repo
 */ 
%skeleton "lalr1.cc"
%require  "3.0"

/* The following section "code requires" finds its way into
 * calc.tab.hxx, so definitions and declarations in this block
 * can be imported into the lexer.
 */
%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "ASTNode.h"  // Abstract syntax tree

}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    void dump(AST::ASTNode* n);
}

%union {
    int   num;
    char* str;
    AST::ASTNode* node;
}

/* -~-~-~ TOKENS -~-~-~ */
%token <str> STRING_LIT
%token <num> INT_LIT

%token CLASS DEF EXTENDS
%token IF ELIF ELSE
%token WHILE RETURN TYPECASE
%token ATLEAST ATMOST EQUALS
%token AND OR NOT
%token IDENT
%token NEG

/* -~-~-~ AST NODES -~-~-~ */
%type <str> IDENT
%type <node> program
%type <node> classes
%type <node> class
%type <node> class_sig
%type <node> class_body
%type <node> ident
%type <node> formal_args
%type <node> formal_args_extra
%type <node> stmt_block
%type <node> stmts
%type <node> stmt
%type <node> elif_nts
%type <node> elif_nt
%type <node> typecase
%type <node> type_alts
%type <node> type_alt
%type <node> r_expr
%type <node> actual_args
%type <node> actual_args_extra
%type <node> l_expr
%type <node> method
%type <node> methods

/* -~-~-~ PRECEDENCE -~-~-~ */
%left AND OR NOT
%left EQUALS ATMOST ATLEAST '<' '>'
%left '-' '+'
%left '*' '/'
%left '.'
%left UMINUS

/* -~-~-~-~-~-~-~-~-~-~-~- GRAMMAR -~-~-~-~-~-~-~-~-~-~-~- */

%%

program : classes stmts { *root = new AST::ASTNode(PROGRAM);
                        $$ = *root; $$->insert($1); $$->insert($2); }
        ;

classes : classes class { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(CLASSES); }
        ;

class : class_sig class_body { $$ = $1; $1->insert($2); }
        ;

class_sig : CLASS ident '(' formal_args ')' 
        { $$ = new AST::ASTNode(CLASS); $$->insert($2); $$->insert($4); }
        | CLASS ident '(' formal_args ')' EXTENDS ident
        { $$ = new AST::ASTNode(CLASS); $$->insert($2);
        $$->insert($4); $$->insert($7); }
        ;

class_body : '{' stmts methods '}' { $$ = new AST::ASTNode(BLOCK); 
                                    $$->insert($2); $$->insert($3); }
        ;

formal_args : ident ':' ident formal_args_extra { $$ = new AST::ASTNode(FORMAL_ARGS); $$->insert($1); $$->insert($3); $$->insert($4); }
        | /* empty */ { $$ = NULL; } // when this is passed back to class_sig we don't want to insert a null node
        ;

formal_args_extra: formal_args_extra ',' ident ':' ident { $$ = new AST::ASTNode(FORMAL_ARGS_EXTRA); $$->insert($3); $$->insert($5); }
        | /* empty */ { $$ = NULL; }
        ;

stmt_block : '{' stmts '}' { $$ = new AST::ASTNode(BLOCK); $$->insert($2); }
        ;

stmts : stmts stmt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(BLOCK); }
        ;

stmt : IF r_expr stmt_block elif_nts { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); $$->insert($4); }
        | IF r_expr stmt_block elif_nts ELSE stmt_block { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); $$->insert($4); $$->insert($6); }
        | WHILE r_expr stmt_block { $$ = new AST::ASTNode(WHILE); $$->insert($3); }
        | l_expr '=' r_expr ';' { $$ = new AST::ASTNode(ASSIGN); $$->insert($1); $$->insert($3); }
        | l_expr ':' ident '=' r_expr ';' { $$ = new AST::ASTNode(ASSIGN); $$->insert($1); $$->insert($3); $$->insert($5); }
        | r_expr ';' { $$ = $1; }
        | RETURN r_expr ';' { $$ = new AST::ASTNode(RETURN); $$->insert($2); }
        | RETURN ';' { $$ = new AST::ASTNode(RETURN); }
        | typecase { $$ = $1; }
        ;

elif_nts : elif_nts elif_nt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(IF); }
        ;

elif_nt : ELIF r_expr stmt_block { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); }
        ;

typecase : TYPECASE r_expr '{' type_alts '}' { $$ = new AST::ASTNode(TYPECASE); $$->insert($2); $$->insert($4); }
        ;

type_alts : type_alts type_alt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(TYPE_ALTERNATIVES); }
        ;

type_alt : ident ':' ident stmt_block { $$ = new AST::ASTNode(TYPE_ALTERNATIVE); $$->insert($1); $$->insert($3); $$->insert($4); }
        ;

r_expr : STRING_LIT { $$ = new AST::ASTNode(STRCONST, std::string($1)); }
        | INT_LIT { $$ = new AST::ASTNode(INTCONST, $1); }
        | l_expr { $$ = $1; }
        | '-' r_expr %prec UMINUS { $$ = new AST::ASTNode(BINOP); $$->insert($2); $$->name = "UMINUS"; }
        | r_expr '*' r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "MULT"; }
        | r_expr '/' r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "DIV"; }
        | r_expr '+' r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "PLUS"; }
        | r_expr '-' r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "MINUS"; }
        | r_expr EQUALS r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "EQ"; }
        | r_expr ATMOST r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "ATMOST"; }
        | r_expr '<' r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "LESSER"; }
        | r_expr ATLEAST r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "ATLEAST"; }
        | r_expr '>' r_expr { $$ = new AST::ASTNode(BINOP); $$->insert($1); $$->insert($3); $$->name = "GREATER"; }
        | r_expr AND r_expr { $$ = new AST::ASTNode(AND); $$->insert($1); $$->insert($3); }
        | NOT r_expr { $$ = new AST::ASTNode(NOT); $$->insert($2); }
        | r_expr OR r_expr { $$ = new AST::ASTNode(OR); $$->insert($1); $$->insert($3); }
        | '(' r_expr ')' { $$ = $2; }
        | r_expr '.' ident '(' actual_args ')' { $$ = new AST::ASTNode(DOT); $$->insert($1); $$->insert($3); $$->insert($5);}
        | ident '(' actual_args ')' { $$ = new AST::ASTNode(CALL); $$->insert($1); $$->insert($3); }
        ;

actual_args : r_expr actual_args_extra { $$ = new AST::ASTNode(ACTUAL_ARGS); $$->insert($1); $$->insert($2); }
        | /* empty */ { $$ = NULL; }
        ;

actual_args_extra : actual_args_extra ',' r_expr { $$ = new AST::ASTNode(ACTUAL_ARGS_EXTRA); $$->insert($1); $$->insert($3); }
        | /* empty */ { $$ = NULL; }
        ;

l_expr : ident { $$ = new AST::ASTNode(L_EXPR); $$->insert($1); }
        | r_expr '.' ident { $$ = new AST::ASTNode(L_EXPR); $$->insert($1); $$->insert($3); }
        ;

method : DEF ident '(' formal_args ')' stmt_block { $$ = new AST::ASTNode(METHOD); 
                                                    $$->insert($2); $$->insert($4);
                                                    $$->insert($6); }
        | DEF ident '(' formal_args ')' ':' ident stmt_block { $$ = new AST::ASTNode(METHOD); 
                                                    $$->insert($2); $$->insert($4);
                                                    $$->insert($7); $$->insert($8); }
        ;

methods : methods method { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(METHODS); }
        ;

ident: IDENT { $$ = new AST::ASTNode(IDENT, $1); }
    ;

%%

/* -~-~-~-~-~-~-~-~-~-~-~- -~-~-~- -~-~-~-~-~-~-~-~-~-~-~- */

#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
    report::error_at(loc, msg);
}
