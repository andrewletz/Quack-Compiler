%skeleton "lalr1.cc"
%require  "3.0"

// This is how to get the header files into the parser as well
// as include whatever you wish in the files it generates
%code requires {
  namespace yy {
    class Lexer;  // RE/Flex generates this class with namespace=yy lexer=Lexer
  }
  #include "ASTNode.h"  // Including the AST Classes
}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { AST::ASTNode** root }  /* To pass AST root back to driver */

%code {
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  // Within Bison's parse() we should invoke lexer.yylex(), not the global yylex()
    void dump(AST::ASTNode* n);
    AST::ASTNode *getCallNode(Type callType, std::string callStr, AST::ASTNode *dollarOne, AST::ASTNode *dollarThree) {
        AST::ASTNode *retVal = new AST::ASTNode(CALL); retVal->subType = callType; retVal->insert(dollarOne);
        AST::ASTNode *method = new AST::ASTNode(IDENT, callStr); method->subType = METHOD; 
        retVal->insert(method);
        AST::ASTNode *actuals = new AST::ASTNode(ACTUAL_ARGS);
        actuals->insert(dollarThree);
        retVal->insert(actuals);
        return retVal;
    }
}

%union {
    int   num;
    char* str;
    AST::ASTNode* node;
}

// -~-~-~- TOKENS -~-~-~-
%token <str> STRING_LIT
%token <num> INT_LIT

%token CLASS DEF EXTENDS
%token IF ELIF ELSE
%token WHILE RETURN TYPECASE
%token ATLEAST ATMOST EQUALS
%token AND OR NOT
%token IDENT
%token NEG

// -~-~-~- AST NODES -~-~-~-
%type <str> IDENT
%type <node> program
%type <node> classes
%type <node> class
%type <node> extends
%type <node> formal_args
%type <node> args arg
%type <node> stmt_block
%type <node> stmts
%type <node> stmt
%type <node> elif_nts
%type <node> elif_nt
%type <node> typecase
%type <node> type_alts
%type <node> type_alt
%type <node> r_expr
%type <node> actual_args
%type <node> actuals actual
%type <node> l_expr
%type <node> method
%type <node> methods
%type <node> ident

// -~-~-~- PRECEDENCE -~-~-~-
%left AND OR NOT
%left EQUALS ATMOST ATLEAST '<' '>'
%left '-' '+'
%left '*' '/'
%left '.'
%left UMINUS

// -~-~-~- GRAMMAR -~-~-~-

%%

program
        : classes stmts { *root = new AST::ASTNode(PROGRAM); $$ = *root; $$->insert($1); $$->insert($2); }
        ;

classes
        : classes class { $1->insert($2); $$ = $1; }
        | /* empty */   { $$ = new AST::ASTNode(CLASSES); }
        ;

class
        : CLASS ident '(' formal_args ')' extends '{' stmts methods '}' 
            { $$ = new AST::ASTNode(CLASS); 
              $2->subType = CLASS_NAME; $$->insert($2); 
              $$->insert($6); 
              AST::ASTNode *method = new AST::ASTNode(METHOD); 
              method->subType = CONSTRUCTOR;
              AST::ASTNode *methodname = new AST::ASTNode(IDENT, $2->name); 
              methodname->subType = METHOD_NAME;
              method->insert(methodname);
              AST::ASTNode *ret = new AST::ASTNode(IDENT, RETURN_TYPE, $2->name);
              method->insert($4);
              method->insert(ret);
              method->insert($8);
              $$->insert(method);
              $$->insert($9); }
        ;

extends
        : EXTENDS ident { $2->subType = SUPER_NAME; $$ = $2; }
        | /* empty */ { $$ = new AST::ASTNode(IDENT, SUPER_NAME, "Obj"); }
        ;

formal_args
        : args { $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(FORMAL_ARGS); }
        ;

args
        : arg { $$ = new AST::ASTNode(FORMAL_ARGS); $$->insert($1); }
        | args ',' arg { $$ = $1; $1->insert($3); }
        ;

arg
        : ident ':' ident { $$ = new AST::ASTNode(CLASS_ARG); $1->subType = VAR_IDENT; $$->insert($1); 
                            $3->subType = TYPE_IDENT; $$->insert($3); }
        ;

stmt_block
        : '{' stmts '}' { $$ = $2; }
        ;

stmts
        : stmts stmt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(BLOCK); $$->subType = STATEMENTS; }
        ;

stmt
        : IF r_expr stmt_block elif_nts { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); $$->insert($4); }
        | IF r_expr stmt_block elif_nts ELSE stmt_block { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); $$->insert($4); $$->insert($6); }
        | WHILE r_expr stmt_block { $$ = new AST::ASTNode(WHILE); $$->insert($3); }
        | l_expr '=' r_expr ';' { $$ = new AST::ASTNode(ASSIGN); $$->insert($1); $3->subType = R_EXPR; $$->insert($3); }
        | l_expr ':' ident '=' r_expr ';' { $$ = new AST::ASTNode(ASSIGN); $$->insert($1); $$->insert($3); $$->insert($5); }
        | r_expr ';' { $$ = $1; }
        | RETURN r_expr ';' { $$ = new AST::ASTNode(RETURN); $2->subType = R_EXPR; $$->insert($2); }
        | RETURN ';' { $$ = new AST::ASTNode(RETURN); }
        | typecase { $$ = $1; }
        ;

elif_nts 
        : elif_nts elif_nt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(IF); }
        ;

elif_nt 
        : ELIF r_expr stmt_block { $$ = new AST::ASTNode(IF); $$->insert($2); $$->insert($3); }
        ;

typecase
        : TYPECASE r_expr '{' type_alts '}' { $$ = new AST::ASTNode(TYPECASE); $$->insert($2); $$->insert($4); }
        ;

type_alts
        : type_alts type_alt { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(TYPE_ALTERNATIVES); }
        ;

type_alt 
        : ident ':' ident stmt_block { $$ = new AST::ASTNode(TYPE_ALTERNATIVE); $$->insert($1); $$->insert($3); $$->insert($4); }
        ;

r_expr
        : STRING_LIT { $$ = new AST::ASTNode(STRCONST, std::string($1)); }
        | INT_LIT { $$ = new AST::ASTNode(INTCONST, $1); }
        | l_expr { $$ = new AST::ASTNode(LOAD); $$->insert($1); $$->subType = L_EXPR; }
        | '-' r_expr %prec UMINUS { AST::ASTNode *zero = new AST::ASTNode(INTCONST, 0);
                                    $$ = getCallNode(MINUS, "MINUS", zero, $2); }
        | r_expr '*' r_expr { $$ = getCallNode(MULT, "MULT", $1, $3); }
        | r_expr '/' r_expr { $$ = getCallNode(DIV, "DIV", $1, $3); }
        | r_expr '+' r_expr { $$ = getCallNode(PLUS, "PLUS", $1, $3); }
        | r_expr '-' r_expr { $$ = getCallNode(MINUS, "MINUS", $1, $3); }
        | r_expr EQUALS r_expr { $$ = getCallNode(EQ, "EQ", $1, $3); }
        | r_expr ATMOST r_expr { $$ = getCallNode(ATMOST, "ATMOST", $1, $3); }
        | r_expr '<' r_expr { $$ = getCallNode(LESSER, "LESSER", $1, $3); }
        | r_expr ATLEAST r_expr { $$ = getCallNode(ATLEAST, "ATLEAST", $1, $3); }
        | r_expr '>' r_expr { $$ = getCallNode(GREATER, "GREATER", $1, $3); }
        | r_expr AND r_expr { $$ = getCallNode(AND, "AND", $1, $3); }
        | r_expr OR r_expr { $$ = getCallNode(OR, "OR", $1, $3); }
        | NOT r_expr { $$ = new AST::ASTNode(NOT); $$->insert($2); } 
        | '(' r_expr ')' { $$ = $2; }
        | r_expr '.' ident '(' actual_args ')' { $$ = new AST::ASTNode(CALL); $$->insert($1); $3->subType = METHOD;
                                                 $$->insert($3); $$->insert($5);}
        | ident '(' actual_args ')' { $$ = new AST::ASTNode(CONSTRUCTOR); $$->insert($1); $$->insert($3); }
        ;

actual_args
        : actuals { $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(ACTUAL_ARGS); }
        ;

actuals
        : actual { $$ = new AST::ASTNode(ACTUAL_ARGS); $$->insert($1); }
        | actuals ',' actual { $$ = $1; $1->insert($3); }
        ;

actual
        : r_expr { $$ = new AST::ASTNode(METHOD_ARG); $$->insert($1); }
        ;

l_expr
        : ident { $$ = $1; $$->subType = LOC; /* new AST::ASTNode(LOAD); $$->insert($1); */ }
        | r_expr '.' ident { $$ = new AST::ASTNode(DOT); $$->subType = L_EXPR; $$->insert($1); $3->subType = R_EXPR; $$->insert($3); }
        ;

method
        : DEF ident '(' formal_args ')' stmt_block { $$ = new AST::ASTNode(METHOD); $2->subType = METHOD_NAME; $$->insert($2); $$->insert($4); $6->subType = STATEMENTS; $$->insert($6); }
        | DEF ident '(' formal_args ')' ':' ident stmt_block { $$ = new AST::ASTNode(METHOD); $2->subType = METHOD_NAME; $$->insert($2); $$->insert($4); $7->subType = RETURN; $$->insert($7); $8->subType = STATEMENTS; $$->insert($8); }
        ;

methods
        : methods method { $1->insert($2); $$ = $1; }
        | /* empty */ { $$ = new AST::ASTNode(METHODS); }
        ;

ident
        : IDENT { $$ = new AST::ASTNode(IDENT, $1); }
        ;

%%

// -~-~-~- -~-~-~- -~-~-~-~

#include "Messages.h"

void yy::parser::error(const location_type& loc, const std::string& msg)
{
    report::error_at(loc, msg);
}