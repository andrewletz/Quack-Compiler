class hierarchy check (phase 1):
	done in type checker initialization (but still a part of phase 1):
		- check if class extends no such super 
			-> Class "__" extends non-existant class "__"
		- check if a method name is the same as the class name it resides in
			->
		- check if a class has already been defined (no class redefinition allowed)
			-> Class "__" has already been defined!


	- check if there is a circular dependency 
			-> Circular dependency detected
	
	- check if class method definitions are compatible with parent's 
			-> Class "__"'s method "__" incompatible with super class "__"'s definition

init before use on constructors (phase 2):
	for each class constructor,
	- check that each variable is initialized on all paths before use
		for each stmt in constructor,
		- add it to the type vector with type NONE (or something)
		- if a leaf boils down to a literal (string, int, bool or none) then it is initialized
		- if not, check if its init already
				-> Class "__": variable "__" used before initialized on all paths

	for each class again,
	- compare constructors instanceVars to parent's instanceVars (just by name, no type yet).
		(the child must define all the instance vars of the parent!)
			-> Child class "__" of parent "__" does not define instance variable "__"

init before use on methods (phase 3):
	for each method in a class,
	- check that each variable is initialized on all paths before use
		- if a variable is of form this.x
			- check that this.x exists in Qclass' instanceVars
			- if not,
				-> Unknown instance variable "__" used in method "__"
			- if it is, it is initialized (we can assume this because we do all constructors first)
		- add it to the type vector with type NONE (or something)
		- if a leaf boils down to a literal (string, int, bool or none) then it is initialized
		- if not, check if its init already
				-> Class "__": variable "__" used before initialized on all paths


type inference on constructors (phase 3):
- 



notes:
- if an error occurs in a method with the same name as the class, it is the constructor
- if an error occurs in $MAIN(), it is in the main statements area

Assumptions/decisions based on ambiguity:
- you cannot assign explicit type more than once
- you cannot reassign to "this" (eg, this = 10;)
- you cannot use the keyword "this" inside the main program statements
- you may not have a method with the same name as a class
- you may not have a field with the same name as a class or method


















###########################
-~-~-~-~-~-~-~-~ stmt -~-~-~-~-~-~-~-~

IF r_expr stmt_block opt_elif
					 ELIF r_expr stmt_block opt_elif
					 ELSE stmt_block
					 /* empty */  

WHILE r_expr stmt_block

l_expr '=' r_expr ';'
l_expr ':' ident '=' r_expr ';'
r_expr ';' { $$ = $1; }
RETURN r_expr ';'
RETURN ';'
typecase

	-~-~-~-~-~-~-~-~ l_expr -~-~-~-~-~-~-~-~
	ident				-> IDENT, LOC
	r_expr '.' ident	-> DOT, L_EXPR

	-~-~-~-~-~-~-~-~ r_expr -~-~-~-~-~-~-~-~
	l_expr
	STRING_LIT
	INT_LIT
	'-' r_expr
	r_expr '*' r_expr
	r_expr '/' r_expr
	r_expr '+' r_expr
	r_expr '-' r_expr
	r_expr EQUALS r_expr
    r_expr ATMOST r_expr
    r_expr '<' r_expr
    r_expr ATLEAST r_expr
    r_expr '>' r_expr
    r_expr AND r_expr
    r_expr OR r_expr
    NOT r_expr
    '(' r_expr ')'
    r_expr '.' ident '(' actual_args ')'
    ident '(' actual_args ')'