%top{
// Quack scanner
// Acknowledgements: Michal Young for skeleton file

#include "quack.tab.hxx"  // Generated by bison.
#include "Messages.h"

%}

%{
// Externally visible file name -- for error messages.
// FIXME: Need to extract this from structures that reflex passes
// or else find another way to dig it out.
std::string yyfilename = "Quack";

// Some strings can't be matched in one gulp.  We need
// a buffer in which to assemble them from parts.
std::string string_buf = "";

void yyerror (const std::string &msg, yy::position* where) {
     std::cout << where << ": " << msg;
}

std::string unclosedStringMsg(int lineno, int columno) {
    return "possible unclosed string at line " + std::to_string(lineno) + ", column " + std::to_string(columno);
}

std::string BAD_ESC_MSG =
    "illegal escape code; only \\\\, \\0, \\t, \\n, \\r, and \\n are permitted";

std::string badEscMsg(int lineno, int columno) {
    return BAD_ESC_MSG + "... found at line " + std::to_string(lineno) + ", column " + std::to_string(columno);
}

std::string UNCLOSED_COMMENT_MSG =
    "possible unclosed multiline comment, reason: EOF encountered; exiting with error code 4";

std::string UNCLOSED_STRING_MSG =
    "possible unclosed multiline string, reason: EOF encountered; exiting with error code 4";

std::string unexpectedCharMsg(int lineno, int columno, const char *text) {
    return "unexpected character '" + std::string(text) + "'" + " at line " + std::to_string(lineno) +
           ", column " + std::to_string(columno);
}

%}

%option bison-cc bison-locations noyywrap
%option namespace=yy lexer=Lexer lex=yylex

/* ============== */
/* Scanner States */
/* ============== */

%x comment
%x string
%x multistring

%%

/* ======================== */
/* Non-Value Bearing Tokens */
/* ======================== */

// Multi-character punctuation with names
==   { return parser::token::EQUALS; }
[<]= { return parser::token::ATMOST; }
[>]= { return parser::token::ATLEAST; }


// Single character punctuation.  Because a character
// in C or C++ can be treated as an integer, Bison lets
// us return a character as a token.

[-+*/><{}=(),;.:] { return text()[0]; }

// Keywords are essentially another kind of punctuation,
// but since they also match the identifier pattern, we
// need to be sure we give their patterns *before* the
// identifier pattern.

class    { return parser::token::CLASS; }
def      { return parser::token::DEF; }
extends  { return parser::token::EXTENDS; }
if       { return parser::token::IF; }
elif     { return parser::token::ELIF; }
else     { return parser::token::ELSE; }
while    { return parser::token::WHILE; }
return   { return parser::token::RETURN; }
typecase { return parser::token::TYPECASE; }
and      { return parser::token::AND; }
or       { return parser::token::OR; }
not      { return parser::token::NOT; }


/* ==================== */
/* Value Bearing Tokens */
/* ==================== */

// The following tokens are value-bearing:
// We pass a value back to the parser by copying
// it into the yylval parameter. The parser
// expects string values for identifiers and
// string literals in yylval.str.  It expects integer
// values for integer literals in yylval.num.

// Int literals
[0-9]+ { yylval.num = atoi(text()); return parser::token::INT_LIT; }

// Identifiers
[a-zA-Z_][a-zA-Z_0-9]* { yylval.str = strdup(text()); return parser::token::IDENT; }

// Single-line String literals
\"                      { string_buf.clear(); start(string); }
<string>\"              { start(INITIAL); yylval.str = strdup(string_buf.c_str()); return parser::token::STRING_LIT; }
<string>\n              { start(INITIAL); report::error(unclosedStringMsg(lineno(), columno()), LEXER); }
<string>\\[^0btnrf\"\\] { report::error(badEscMsg(lineno(), columno()), LEXER); }
<string>\\0             { string_buf.append("\0"); }
<string>\\b             { string_buf.append("\b"); }
<string>\\t             { string_buf.append("\t"); }
<string>\\n             { string_buf.append("\n"); }
<string>\\r             { string_buf.append("\r"); }
<string>\\f             { string_buf.append("\f"); }
<string>\\\"            { string_buf.append("\""); }
<string>\\\\            { string_buf.append("\\"); }
<string>.               { string_buf.append(text()); }

// Multi-line String Literals
\"\"\" { string_buf.clear(); start(multistring); }
<multistring>\"\"\"  { start(INITIAL); yylval.str = strdup(string_buf.c_str()); return parser::token::STRING_LIT; }
<multistring><<EOF>> { report::error(UNCLOSED_STRING_MSG, LEXER); report::bail(LEXER); }
<multistring>\n      { string_buf.append("\n"); }
<multistring>\r      { string_buf.append("\r"); }
<multistring>\t      { string_buf.append("\t"); }
<multistring>.       { string_buf.append(text()); }

// Ignore whitespace
[ \r\t\n]* { ; }

// Single-line Comments
"//".* { ; }

// Multi-line Comments 
[/][*]           { start(comment); }
<comment>[^*]*   { ; }
<comment>[*][^/] { ; }
<comment><<EOF>> { report::error(UNCLOSED_COMMENT_MSG, LEXER); report::bail(LEXER); }
<comment>[*][/]  { start(INITIAL); }

. { report::error(unexpectedCharMsg(lineno(), columno(), text()), LEXER); }

<<EOF>> { return EOF; }

%%

// No main program here

