class hierarchy check (phase 1):
	done in type checker initialization (but still a part of phase 1):
		- check if class extends no such super 
			-> Class "__" extends non-existant class "__"
		- check if a method name is the same as the class name it resides in
			->
		- check if a class has already been defined (no class redefinition allowed)
			-> Class "__" has already been defined!


	- check if there is a circular dependency 
			-> Circular dependency detected
	
	- check if class method definitions are compatible with parent's 
			-> Class "__"'s method "__" incompatible with super class "__"'s definition

init before use on constructors (phase 2):
	for each class constructor,
	- check that each variable is initialized on all paths before use
		for each stmt in constructor,
		- add it to the type vector with type NONE (or something)
		- if a leaf boils down to a literal (string, int, bool or none) then it is initialized
		- if not, check if its init already
				-> Class "__": variable "__" used before initialized on all paths

	for each class again,
	- compare constructors instanceVars to parent's instanceVars (just by name, no type yet).
		(the child must define all the instance vars of the parent!)
			-> Child class "__" of parent "__" does not define instance variable "__"

init before use on methods (phase 3):
	for each method in a class,
	- check that each variable is initialized on all paths before use
		- if a variable is of form this.x
			- check that this.x exists in Qclass' instanceVars
			- if not,
				-> Unknown instance variable "__" used in method "__"
			- if it is, it is initialized (we can assume this because we do all constructors first)
		- add it to the type vector with type NONE (or something)
		- if a leaf boils down to a literal (string, int, bool or none) then it is initialized
		- if not, check if its init already
				-> Class "__": variable "__" used before initialized on all paths


type inference on constructors (phase 3):
- 



notes:
- if an error occurs in a method with the same name as the class, it is the constructor
- if an error occurs in $MAIN(), it is in the main statements area
- method signatures are checked based on type and number of arguments, not by name of the arguments. ie, a sub class can rename an overriden method's arguments but not change their type.

Assumptions/decisions based on ambiguity:
- class constructor arguments must be a super set of their parent
- you may only assign an explicit type that is a sub-type or equal to the variable's current type
	- if it is the first declaration of that variable, you may declare any
	explicit type. (however, if the value on the right hand side of the expression is of the wrong type, you will get a type error)
- you cannot reassign "this" (eg, this = 10;)
- you cannot use the keyword "this" inside the main program statements
- you cannot pass "this" as an argument in a constructor
- you cannot assign a variable to "this" in a constructor
- you may not have an explicit "return" statement in a constructor
- you may not have a method with the same name as a class
- you may not have a field with the same name as a class or method
- method and class arguments are treated as explicit declarations

















###########################
-~-~-~-~-~-~-~-~ stmt -~-~-~-~-~-~-~-~

IF r_expr stmt_block opt_elif
					 ELIF r_expr stmt_block opt_elif
					 ELSE stmt_block
					 /* empty */  

WHILE r_expr stmt_block

l_expr '=' r_expr ';'
l_expr ':' ident '=' r_expr ';'
r_expr ';' { $$ = $1; }
RETURN r_expr ';'
RETURN ';'
typecase

	-~-~-~-~-~-~-~-~ l_expr -~-~-~-~-~-~-~-~
	ident				-> IDENT, LOC
	r_expr '.' ident	-> DOT, L_EXPR

	-~-~-~-~-~-~-~-~ r_expr -~-~-~-~-~-~-~-~
	l_expr
	STRING_LIT
	INT_LIT
	'-' r_expr
	r_expr '*' r_expr
	r_expr '/' r_expr
	r_expr '+' r_expr
	r_expr '-' r_expr
	r_expr EQUALS r_expr
    r_expr ATMOST r_expr
    r_expr '<' r_expr
    r_expr ATLEAST r_expr
    r_expr '>' r_expr
    r_expr AND r_expr
    r_expr OR r_expr
    NOT r_expr
    '(' r_expr ')'
    r_expr '.' ident '(' actual_args ')'
    ident '(' actual_args ')'